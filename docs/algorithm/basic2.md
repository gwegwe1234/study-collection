# 알고리즘 기초 2

[[toc]]

## 브루트 포스

### 브루트 포스 
- 모든 방법을 다 시도해보는 방법
- 전체 경우의 수가 많지 않을 경우에만 쓴다.
- 경우의 수를 다 해보는데 걸리는 시간이 문제의 시간 제한을 넘지 않아야 한다.

```java
문제를 풀기위한 단계 

1. 문제의 가능한 경우의 수를 다 계산해 본다.
2. 가능한 모든 방법을 다 만들어 본다.
3. 각각의 방법을 이용해 답을 구해본다.
```

- 시간복잡도 = 방법의 수 X 방법 1개의 시간 복잡도

### 경우의 수
- 문제의 가능한 경우의 수를 계산해서 다해보는 것 

### 일곱 난쟁이
- 아홉 명의 난쟁이 중 일곱명의 난쟁이를 찾는 문제
- 일곱 난쟁이의 키의 합이 100이다.
- 9C2 = 36가지 경우의 수
- [구현 소스](https://github.com/gwegwe1234/AlgorithmStudy/blob/master/CodePlusAlgo/src/basic2/SevenDwarves.java)

### 사탕 게임
- N*N 개의 칸에 사탕이 들어있다.
- 인접한 곳의 사탕을 옮겨 같은 색의 사탕중 가장 많이 먹을 수 있는 경우의 수
- 오른쪽 / 아래 의 케이스만 따져 브루트포스로 전부다 비교해본다.
- [구현 소스](https://github.com/gwegwe1234/AlgorithmStudy/blob/master/CodePlusAlgo/src/basic2/CandyGame.java)

### 날짜 계산
- E, S, M 으로 날짜를 센다.
- [링크](https://www.acmicpc.net/problem/1476)
- 경우의 수가 15 x 28 x 19 로 8천개도 안돼서 브루트 포스에 적합하다
- [구현 소스](https://github.com/gwegwe1234/AlgorithmStudy/blob/master/CodePlusAlgo/src/basic2/CalculateCalender.java)

### 리모컨
- TV 채널을 리모컨으로 바꾸는 문제
- 버튼은 0~9 + -
- 일부 숫자버튼이 망가짐
- 현재 채널이 100일 때 N번으로 가는 최소 횟수
- [구현 소스](https://github.com/gwegwe1234/AlgorithmStudy/blob/master/CodePlusAlgo/src/basic2/RemoteControl.java)

### 테트로미노
- N x M 의 칸에 숫자가 있고, 테트리스 블럭을 넣었을때 가장 큰 합을 구하는 문제
- 테트리스 블럭 모양으로 나올 수 있는 경우는 총 19가지 (네모, 기역, 일자 등등..)
- 모든 경우의 수는 19 x N x M 이므로, 브루트 포스에 적합하다.
- 모든 케이스를 배열로 나타내서 if문 19개 생성해서 구함

## 건너 뛰며 해보기

### 카잉 달력
- M과 N보다 작거나 같은 두 자연수 x,y를 이용해서 년도를 <x:y>로 표현한다
- 첫 번째 해는 <1:1>, 두 번째 해는 <2,2>
- x < M -> x +1, 아니면 x = 1
- y < N -> y +1, 아니면 y = 1
- 총 갯수가 16억개라 건너뛰면서 해야한다
- M 번 건너뛰면서만 체크해주면 된다.
- 나머지 계산이 필요한 문제는 보통 -1을 해서 하는게 편하다 (5면 5로 나눴을 때 나머지가 0이어야 되는데 그냥 5가나오고 이런문제 발생 가능)
- 어려움..
- [구현 소스](https://github.com/gwegwe1234/AlgorithmStudy/blob/master/CodePlusAlgo/src/basic2/CainCalender.java)

### 수 이어 쓰기 1
- 1부터 N까지 수를 이어서 쓰면 새로운 하나의 수를 얻게 된다. (1 <= N <= 100,000,000)
- 12345678910111213...
- 새로운 수는 몇자리일까?
- [구현 소스](https://github.com/gwegwe1234/AlgorithmStudy/blob/master/CodePlusAlgo/src/basic2/NumberMarathonWriting.java)

### 1,2,3 더하기
- N중 포문
- 이걸 써야되나..??
- 10중 포문인데.. 재귀함수로 풀라그런다.

## N과 M
- 재귀
- 순열
- 비트마스크
- 좀 더 자세하게 공부할 필요가 있어보인다.
- 헷갈림 ㅠ.ㅠ 알고리즘 어려워..

### N과 M(1)
- 1부터 N까지 자연수 중에서 중복없이 M개를 고른 수열을 모두 구하는 문제
- N = 5, M = 3 (1,2,3)(1,2,4)(1,2,5)(1,3,2)....
- 1 <= M <= N <= 8
- _ _ _ 세 칸에 들어 갈 수 있는 경우의 수를 찾는다
- [구현 소스](https://github.com/gwegwe1234/AlgorithmStudy/blob/master/CodePlusAlgo/src/basic2/NAndM.java)

### N과 M(2)
- 오름차순 추가
- 재귀 조건에 초기값을 넣어주고, 새로 호출할 때 +1을 해준다

### N과 M(3)
- 중복 가능
- N과 M (1) 에서 중복만 삭제

### N과 M(4)
- 중복 가능, 비 내림차순

## 순열
- 브루트 포스인데 순서가 중요한 경우

### 순열
- 임의의 수열을 다른 순서로 섞는 연산
- A = [1,5,6] 인 경우 [1,5,6][1,6,5][5,1,6]...
- 크기가 N인 수열의 서로 다른 순열은 총 N! 개가 있음
- 첫 순열부터 맨 마지막 순열까지 다 구하면된다.
- 다음 순열을 구하는 방법을 구현하면 된다.

### 다음 순열
- 사전순으로 다음에 오는 순열과 이전에 오는 순열을 찾는 방법
- 자바는 기본구현이 안돼서 구현을 해 줘야 한다.
- 첫 순열은 오름차순, 맨 마지막 순열은 내림차순

```java
1. A[i-1] < A[i] 를 만족하는 가장 큰 i를 찾는다
2. j >= i 이면서 A[j] > A[i-1]를 만족하는 가장 큰 j를 찾느다.
3. A[i-1]과 A[j]를 swap 한다.
4. A[i]부터 순열을 뒤집는다.
```

- 뒤에서부터 하나씩 비교해가면서 내림차순이 아닌걸 찾는다. 그러면 앞의 것부터 시작한거의 맨 마지막 순열이 된다.
- 예를 들어 7,2,3,6,5,4,1 이 있으면, 뒤에서부터 비교해 보면 7,2,3으로 시작하는 순열의 맨 마지막 순열인 상태이다.
- 그럼 3을 6,5,4,1 에서의 3보다 크면서 위치가 가장 큰 수를 swap (여기선 4)
- 7,2,4,6,5,3,1 상태가 된다.
- 이제 뒤에껄 뒤집는다, 7,2,4,1,3,5,6, 
- 바로 7,2,3,6,5,4,1의 다음 순열이 된다.
- 시간 복잡도는 O(N)
- 전체를 찾는 시간복잡도는 N * N!
- [구현 소스](https://github.com/gwegwe1234/AlgorithmStudy/blob/master/CodePlusAlgo/src/basic2/NextPermutation.java)

### 이전 순열
- 다 똑같은데 부등호만 반대로 해주면 된다.
- 즉 끝에서부터 오름차순을 쭉 찾다가, 오름차순이 끊기는 지점까지 찾고, 오른쪽 부분에서 가장 큰 수와 끊긴 부분을 교환한다
- 이후 뒤에 오름차순 순열을 뒤집어주면 끝

### 모든 순열
- do while로 돌리면서, nextPermutation 호출해서 프린트 찍어준다. 
- 시작 순열은 전부다 오름차순인 순열
- [구현 소스](https://github.com/gwegwe1234/AlgorithmStudy/blob/master/CodePlusAlgo/src/basic2/EveryPermutation.java)

### 차이를 최대로
- 수 N개가 주어졌을 때 (3 <= N <= 8)
- |A[0] - A[1]| + |A[1] - A[2]| + ... |A[N-2] - A[N-1]|
- 의 최대값 구하기
- 8 보다 작아서 그냥 모든순열 구해서 최댓 값 구하면 된다.
- [구현 소스](https://github.com/gwegwe1234/AlgorithmStudy/blob/master/CodePlusAlgo/src/basic2/BiggestDifferencePermutation.java)

### 외판원 순회 2
- 1번부터 N번까지 번호가 매겨져 있는 도시가 있다
- 한 도시에서 시작해 N개의 모든 도시를 거쳐 다시 원래 도시로 돌아오려고 한다 (한 번 갔던 도시로는 다시 갈 수 없다)
- 이 때 가장 적은 비용을 구하는 문제
- W[i][j] = i -> j 비용이 0인 경우는 갈 수 없음
- N이 매우 커지면 무조건 순열로 푸는건 조심해야 한다.
- 결국 각 도시를 순회하는 방법을 순열로 나타내서, 더하는 부분만 다른 차이를 최대로와 같다
- 여기서 추가로 줄일 수 있는 방법은 1,2,3,4 == 2,3,4,1 == 3,4,1,2 == 4,1,2,3 이다. 즉 시작점을 1로 고정해도 된다.

### 로또
- 입력으로 주어진 K개의 수 중에서 6개의 수를 고르는 문제
- 고르는 걸 1, 안고르는걸 0
- 0을 k-6개, 1을 6개 넣은 다음 nextPermutation 수행하면 모든 조합을 구할 수 있다.

## 재귀
- 문제를 푸는 순서는 아래와 같다.

```java
1. 정답을 찾은 경우
2. 정답을 못구하는 경우 (불가능한 경우)
3. 다음 경우
```

### 1,2,3 더하기
- go(count, sum, goal)
- count -> count + 1
- sum -> sum + i
- 내부 케이스
    - 안되는 경우 -> sum > goal
    - 정답을 찾는 경우  -> sum == goal
    - 다음 경우 호출 -> sum(count + 1, sum + i, goal)
- 근데 카운트는 만들고나면 필요가없다.. 왜쓴거.. 빼면됨

### 암호 만들기
- 암호는 서로다른 L개의 소문자로 구성, 최소 한개의 모음과 2개의 자음 필요
- 암호의 알파벳은 증가하는 순서
- 암호로 사용할 수 있는 문자의 수는 C가지
- 먼저 정렬을 하고 시작한다.
- go(n, alpha, password, i)
    - n : 만들어야 하는 암호의 길이
    - alpha : 사용할 수 있는 알파벳 배열
    - password : 만든 패스워드
    - i : 사용할지 말아야할지 알파벳 인덱스

### 퇴사
- N+1일에 퇴사
- N일까지 최대한 상담을 하는데, 하루에 한번 상담가능
- i일에 상담하면 T[i]일이 걸리고, P[i]원을 받는다

### 백트랙킹
- 다구하고 필요없는거 빼기

### 스타트와 링크
- 두 팀으로 나눠서 차이가 가장 적은거..

## 비트마스크
- 비트 연산을 통해 부분집합을 표현하는 문제
- and or not nor 쉬프트 연산
- 쉬프트 연산은 A << B 면, A x 2의 b승 / A >> B 면, A / 2의 b승
- 비트마스크 : 정수로 집합을 나타낼 수 있다. 
- {1,3,4,5,9} = 570 = 2의1승 + 2의3승 + 2의4승 + 2의5승 + 2의9승
- 정수로 집합을 표현하기 때문에 시간복잡도, 공간복잡도가 아주 작아진다
- 0부터 N-1까지의 정수로 이루어진 집합을 표현 
- 위의 집합에서 0이 포함되어 있는지 확인하려면 = 570 & 2의 0승 을 해서 1이 나오는지 확인하면 된다. (비트연산)
- 숫자를 추가해주는건, 특정 위치의 값만 1으로 바꿔주면 된다. 
- 즉 1을 추가하려면 570 | 2의1승 을 통해 둘중하나가 0이라도 1로 바뀌도록 연산해주면 된다.
- 제거는 not 연산 후 &를 해준다.

## 그래프

### DFS와 BFS까지
- 문제에 나온 상황을 어떻게 그래프로 만들어야 하는지가 중요하다
- 자료구조의 일종
- 정점 (Node, Vertex)
- 간선(Edge): 정점간의 관계를 나타낸다
- G = (V,E) 라고 표현
- 경로 : 정점 A에서 B로 가는 경로(간선의 연속)
- 사이클 : 정점과 도착점이 같은 그래프
- 문제를 그래프로 모델링 해서 푼다.

### 단순 경로와 단순 사이클
- 경로/사이클에서 같은 정점을 두 번 이상 방문하지 않는 경로와 사이클
- 특별한 말이 없으면 일반적으로 단순 경로와 단순 사이클이라고 본다

### 방향 있는 그래프
- 정점간에 방향이 있는 간선이 있을 수 있다.

### 방향 없는 그래프
- 정점간에 방향이 없어, 왔다갔다 가능
- 양방향 그래프라고도 한다
- 보통 문제를 풀때 방향 없는 그래프는 방향 있는 그래프로 바꾼다.
- ex. A-C = A->C / C->A

### 간선 여러개
- 두 정점 사이에 간선이 여러 개 일 수 있다.

### 루프
- 간산의 양 끝점이 같은 경우
- A->A
- 이론적인거고 문제로 풀경운 거의없다

### 가중치
- 간선에 가중치가 있는 경우
- A에서 B로 이동하는 거리, 이동하는데 필요한 시간, 이동하는데 필요한 비용 등등..

### 차수
- 정점과 연결되어 있는 간선의 개수
- 방향 그래프에는 indegree와 outdegree로 나눠서 차수를 계산한다

### 그래프의 표현
- 정점이 6개, 간선이 8개
- 방향이 없는 그래프이다
- 정점 : {1,2,3,4,5,6}
- 간선 : {(1,2), (1,5), (2,5), (2,3), (3,4), (2,4), (4,5), (4,6)}

![alt](../images/codeplus2-1.png)

- 그래프 저장 방법
```java
1. 인접 행렬
2. 인접 리스트
```

### 인접 행렬
- 정점의 개수를 V라고 했을 때,
- V X V 크기의 이차원 배열을 이용한다.
- A[i][j] = 1 (i -> j 간선이 있을때), 0 (없을 때) / 가중치가 있으면 가중치 값을 넣어준다
- 공간 복잡도 : O(V제곱)

### 인접 리스트
- A[i] = i 와 연결된 정점을 리스트로 포함하고 있음
- A[1] = 2,5...
- 가중치가 있으면 A[1] = (2,2) (2,5) 이렇게 준다.
- 링크드리스트 같은 동적으로 길이 변경할 수 있는 배열을 사옹해야 한다.
- 공간 복잡도 : O(E) == 간선의 갯수
- 인접 리스트가 공간,시간복잡도면에서 인접행렬보다 더 좋다.
- 결국 거의 모든 케이스는 인접리스트만 사용한다

### 간선 리스트
- 배열을 이용해서 구현한다.
- 간선을 모두 저장하고 있다.
- 1차원 배열에 싹다 저장하는거

### ABCDE
- 총 N명의 친구 관계가 주어졌을때
- 다음과 같은 친구 관계가 존재하는지 구하는 문제
- A는 B와 친구다.
- B와 C와 친구다
- C D 친구
- D E 친구
- [구현 소스](https://github.com/gwegwe1234/AlgorithmStudy/blob/master/CodePlusAlgo/src/basic2/NextPermutation.java)

### 그래프의 탐색
- 목적 : 임의의 정점에서 시작해서 연결되어 있는 모든 정점을 한번씩 방문하는 것
- DFS / BFS 둘 다 위의 목적을 이루기 위한 알고리즘 방식
- DFS : 깊이 우선 탐색 -> 한명이 왔다갔다 하는방법 (Stack)
- BFS : 너비 우선 탐색 -> 사람이 복제되면서 하는 방법 (Queue)

### 깊이 우선 탐색
- 스택을 이용해서 갈 수 있는 만큼 최대한 많이 가고
- 갈 수 없으면 이전 정점으로 돌아간다
- check 배열을 만든다.
- 특정 정점을 방문하면, check[i] 에 1을 추가한다.
- 방문한곳을 스택에 넣어준다
- 그러다 갈 수 없는곳에 도착하면 스택에서 마지막에 넣은거 뺀다
- 다 가게되면 스택에서 쫘라락 다 빠질텐데, 스택이 비면 모든 정점을 방문했다고 볼 수 있다
- [그림참조](https://codeplusattachment.s3.ap-northeast-1.amazonaws.com/5eef326b6e3cfe22851b09a3842e19d23eb35387/600%20-%20%E1%84%80%E1%85%B3%E1%84%85%E1%85%A2%E1%84%91%E1%85%B3%201.pdf?AWSAccessKeyId=AKIAIZC5BNYL4YLIYQPA&Expires=1607423179&Signature=8x%2FUx3vGf0ezMtuudvqaEf%2FtQXA%3D) 
- 재귀를 통해 구현이 가능하다

```java
// 인접 행렬을 이용한 구현
void dfs(int x) {
    check[x] = true;
    for (int i = 1; i <= n; i++) {
        if (a[x][i] == 1 && check[i] == false) {
            dfs(i);
        }
    }
}
```

- 시간 복잡도는 O(V의 제곱)

```java
// 인접 리스트를 이용한 구현
void dfs(int x) {
    check[x] = true;
    for (int i = 0; i < a[x].size(); i++) {
        // 인접 리스트에 실제 값을 땡겨와서 check함수로 체크한다
        int y = a[x][i];
        if (check[y] == false) {
            dfs(y);
        }
    }
}
```

- 시간 복잡도는 O(V+E)

### 너비 우선 탐색
- 큐를 이용해서 지금위치에서 갈 수 있는 것을 모두 큐에 넣는 방식
- 큐에 넣었을 때 방문했다고 체크해야 한다
- [그림참조](https://codeplusattachment.s3.ap-northeast-1.amazonaws.com/5eef326b6e3cfe22851b09a3842e19d23eb35387/600%20-%20%E1%84%80%E1%85%B3%E1%84%85%E1%85%A2%E1%84%91%E1%85%B3%201.pdf?AWSAccessKeyId=AKIAIZC5BNYL4YLIYQPA&Expires=1607423179&Signature=8x%2FUx3vGf0ezMtuudvqaEf%2FtQXA%3D) 

```java
// 인접행렬
Queue<int> q;
check[1] = true;
q.push(1);

while (!q.empty()) {
    int x = q.front();
    q.pop();
    for (int i = 1; i <= n; i++) {
        if (a[x][i] == 1 && check[i] == false) {
            // 큐에 넣을 때 방문했다고 체크해준다
            check[i] = true;
            q.push(i);
        }
    }
}
```

```java
// 인접 리스트
Queue<int> q;
check[1] = true;
q.push(1);

while (!q.empty()) {
    int x = q.front();
    q.pop();
    for (int i = 0; i < a[x].size(); i++) {
        int y = a[x][i];
        if (check[y] == false) {
            // 큐에 넣을 때 방문했다고 체크해준다
            check[y] = true;
            q.push(y);
        }
    }
}
```

### 연결 요소
- 아래 그림과 같이 나누어져 있지 않은 경우가 있을 수 있음
- 이렇게 나누어진 각각의 그래프를 연결 요소라고 한다.
- 연결 요소에 속한 모든 정점을 연결하는 경로가 있어야 한다.
- 또 따른 연결 요소에 속한 정ㅈ머과 연결하는 경로가 있으면 안된다.
- 아래는 2개의 연결요소로 되어 있다.
- 연결요소를 구하는 것은 DFS나 BFS를 사용하면 된다.
- [구현 소스](https://github.com/gwegwe1234/AlgorithmStudy/blob/master/CodePlusAlgo/src/basic2/FindYungyulYoso.java)

![alt](../images/codeplus2-2.png)

### 이분 그래프
- 그래프를 아래와 같이 A와 B로 나눌 수 있으면 이분 그래프
- A에 포함되어 있는 정점끼리 연결된 간선이 없음
- B에 포함되어 있는 정점끼리 연결된 간선이 없음
- 모든 간선의 한 끝 점은 A에, 다른 끝 점은 B에

![alt](../images/codeplus2-3.png)

### 단지번호붙이기
- 정사각형 모양의 지도가 있다
- 0은 집이 없는곳, 1은 집이 있는곳
- 지도를 가지고 연결된 집의 모임인 단지를 정의하고, 단지에 번호를 붙인다.
- 연결 : 좌우 아래위로 집이 있는 경우

### 섬의 개수

### 미로 탐색
- (1,1)에서 (N,M)으로 가는 가장 빠른 길을 구하는 문제
- DFS로는 못품
- BFS 탐색 사용 
- BFS는 단계별로 진행돼서 구할 수 있음
- [구현 소스](https://github.com/gwegwe1234/AlgorithmStudy/blob/master/CodePlusAlgo/src/basic2/FindBestWayOfMaze.java)

### TwoDots
- [구현 소스](https://github.com/gwegwe1234/AlgorithmStudy/blob/master/CodePlusAlgo/src/basic2/TwoDots.java)

### 서울 지하철 2호선

### BFS 스페셜 저지
- 입력으로 주어진 정보가 BFS 탐색을 진행하면서 올바른 결과인지 살펴본다

### 다리 만들기
- 단지 붙이기 + 토마토

## BFS
- BFS는 모든 가중치가 1일 때 최단 거리를 구하는 알고리즘
- 문제 조건
    - 최소비용 문제이어야 한다
    - 간선의 가중치가 1이어야 한다
    - 정점과 간선의 개수가 적어야 한다

### 숨바꼭질
- 수빈이의 위치 : N
- 동생의 위치 : K
- 동생을 찾는 가장 빠른 시간을 구하는 문제
- 수빈이가 할 수 있는 행동 (위치 : X)
    - 걷기 X+1, X-1로 이동(1초)
    - 순간이동 : 2 * X로 이동 (1초)
- 이 문제에서 정점 : 위치
- 이 문제에서 간선 : 위치 - 위치 (걷기 또는 순간이동)
- check[i] = i를 방문했는지 여부
- dist[i] = i를 몇 번만에 방문했는지 기록
```java
if(check[i]==false) { 
    check[i] = true; 
    q.push(v); 
    dist[v] = dist[u] + 1;
}
```
- [구현 소스](https://github.com/gwegwe1234/AlgorithmStudy/blob/master/CodePlusAlgo/src/basic2/HideAndSeek.java)

### 숨바꼭질 4
- 숨바꼭질 1 에 이동하는 방법도 추가해서 구하는 문제
- 역추적이 필요하다
- from[i] = 어디에서 왔는지
- from[i] -> i
- N에서 K를 가는 문제 이기 때문에
- K부터 from을 통해서 N까지 가야한다.
- 즉 역순으로 저장되기 때문에 역순으로 구하는 것이 필요
- Stack or 재귀로 구해준다.
- [구현 소스](https://github.com/gwegwe1234/AlgorithmStudy/blob/master/CodePlusAlgo/src/basic2/HideAndSeek4.java)

### 이모티콘
- 화면에 이모티콘은 1개
- 할 수 있는 연산
    - 화면에 있는 이모티콘을 모두 복사해서 클립보드에 저장
    - 크립보드에 있는 모든 이모티콘을 화면에 붙여넣기
    - 화면에 있는 이모티콘 중 하나를 삭제
- S개의 이모티콘을 만드는데 걸리는 시간의 최소값을 구하는 문제

### 덱 사용하기
- 가중치가 0과 1인애들도 구할 수 있다

### 숨바꼭질 3
- 순간이동은 시간이 0초걸린다고 가정
- 덱.. 사용..

## 트리
- 자료구조의 일종
- 사이클이 없는 연결 그래프
- 정점의 개수 : V
- 간선의 개수 : V-1
- 연결되어 있다

### 루트 있는 트리
- 루트는 정하기 나름
- 부모관계가 생김
- parent가 없는 노드는 루트이다
- 자식이 없는 노드는 단말 정점 or Leaf 노드
- 형제도 있음
- 깊이 : 루트에서부터의 거리
- 조상, 자손 : p->q로 루트를 통과하지 않고 갈 수 있을 때

### 이진 트리
- 자식을 최대 2개만 가지고 있는 트리

### 포화 이진 트리
- 리프노드를 제외한 노드의 자식수는 2
- 형제 노드의 수가 일정하게 늘어난다

### 완전 이진 트리
- 리프노드의 자식 수 : 0 
- 포화 이진트리랑은 다르게 높이가 다를 수 있다

### 트리의 표현
- 트리는 그래프이기 때문에, 그래프의 표현과 같은 방식으로 저장할 수 있다.
- 또는
- 트리의 모든 노드는 부모를 하나 또는 0개만 가지기 때문에 부모만 저장하는 방식으로 저장할 수 있다
- 부모가 0개인 경우는 트리의 루트인데, 이 경우 부모를 -1 또는 0으로 처리하는 방식을 사용한다
- `완전 이진 트리`의 경우에는 배열로 표현할 수 있다.
- 부모의 노드가 x인 경우에 자식의 노드는 2*x, 2*x+1로 나타내면 된다.
- 그냥 이진트리의 경우에는 클래스나 구조체로 표현 가능

### 트리의 순회
- 트리의 모든 노드를 방문하는 순서이다.
- 그래프의 경우에는 DFS와 BFS가 있다
- DFS는 아래와 같은 3가지 출력 순서가 있다
    - 프리오더 : 노드방문 - 왼쪽 자식 프리오더 - 오른쪽 자식 프리오더
    - 인오더 : 왼쪽 자식 인오더 - 노드방문 - 오른쪽 자식 인오더
    - 포스트오더 : 왼쪽자식 포스트오더 - 오른쪽 자식 포스트오더 - 노드방문
- 세 방법의 차이는 노드 방문 처리를 언제 할 것인가이다.
- [구현 소스](https://github.com/gwegwe1234/AlgorithmStudy/blob/master/CodePlusAlgo/src/basic2/TreeCircuit.java)

### 트리의 탐색
- 트리의 탐색은 DFS/BFS 알고리즘을 이용해서 할 수 있다.
- 트리는 사이클이 없는 그래프이기 때문
- 임의의 두 정점 사이의 경로는 1개이다.
- 따라서, BFS 알고리즘을 이용해서 최단 거리를 구할 수 있다.
- 이유 : 경로가 1개라 찾은 그 경로가 최단 경로

### 트리의 부모 찾기
- 트리를 그래프로 입력받고
- 루트를 1이라고 정했을 때
- 각 노드의 부모를 찾는 문제
- BFS로 해결 가능

### 트리의 지름
- 트리에 존재하는 모든 경로 중에서 가장 긴 것의 길이를 트리의 지름이라고 한다
- 트리의 지름은 탐색 2번으로 구할 수 있다.

```java
1. 한 정점 s에서 모든 정점까지의 거리를 구한다. 이 때 가장 먼 거리인 정점을 u라고 한다
2. u에서 모든 정점까지의 거리를 구한다. 이 때 가장 먼 거리인 정점 v를 구한다.
```

- d(u,v)를 u와 v사이의 거리라고 했을 때, d(u,v)기 트리의 지름