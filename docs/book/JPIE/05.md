# 5강
## 리스트
- 특정 값들이 순차적으로 정렬된 컬렉션
- 많이 사용하는건 LinkedList와 ArrayList
- 어떠한 리스트를 사용할 지는 상황에 맞춰서 골라야 한다
- 상황에 따라 더 적합한 리스트종류가 있으니 잘 고민해보자

## 배열과 리스트의 관계
- 리스트 구현 방법의 차이를 살펴보기 전에 배열이 어떻게 동작하는지 확인해보자

```java
@Test
public void arrayDefinitions() {
    final int[] integers = new int[3];
    final boolean[] bools = {false, true, true, false};
    final String[] strings = new String[] {"one", "two"};

    final Random r = new Random();
    final String[] randomArrayLength = new String[r.nextInt(100)];    
}
```

- 배열은 알다시피 크기를 정해줘야 쓸 수 있다.
- int 처럼 명시적으로 지정해도 되고, bools 처럼 암묵적으로 정해줘도 된다.
- 뭐가 됐건 배열은 JVM에서 돌리려면 반드시 사이즈를 알아야 한다.
- 인덱스 값으로 배열에 접근이 가능한데, 배열 주소값으로 찾아가는 형태
- 배열을 늘리는건 크기가 더 큰 배열을 만들어서 싹다 복사후에 바라보는 주소를 바꾸는 형태이다

```java
@Test
public void arrayCopy() {
    int[] integers = {0, 1, 2, 3, 4};

    int[] newIntegerArray = new int[integers.length + 1];
    System.arraycopy(integers, 0, newIntegersArray, 0, integers.length);
    integers = newIntegersArray;
    integers[5] = 5;

    assertEquals(5, integers[5]);
}
```

- 요렇게 재할당을 해주는 경우에 배열대신에 List 인터페이스를 사용할 수가 있다.
- ArrayList는 인덱스 값으로 바로 저장된 값을 찾기가 쉽다.
- ArrayList는 배열의 초기 크기를 지정 할 수 있다.
- 만약 꽉찬 ArrayList에 새로운 원소를 추가하면 ArrayList는 자동으로 더 큰 배열을 재할당 한다.
- 그래서 계속 늘려서 배열 메모리를 많이 먹느니, 처음부터 크게 잡는게더 나을 수도 있다.
- 만약 ArrayList 중간에 뭘 추가할라고하면, 또 새로 만들어야되서 매우 비효울적이다.
- 또한 ArrayList원소를 삭제한다고 배열 사이즈가 줄어드는 것도 아니다.
- 따라서 원소의 개수가 계속 변하는 리스트라면 LinkedList가 더 낫다

```java
public class SimpleLinkedList<E> {
    private static class Element<E> {
        E value;
        Element<E> next;
    }
    private Element<E> head;
}
```

- LinkedList 인스턴스는 Element라는 리스트의 첫 부분을 가리키는 head값만 참조한다.
- Element 클래스 내부엔 다음 원소를 가리키는 재귀타입의 next가 있어서, 리스트 사이에 넣고 빼고가 쉽다.

![Alt text](../../images/book/linkedList1.png)

- 원소 추가 하는 방법

![Alt text](../../images/book/linkedList2.png)

- 원소 빼는 방법

### 정리
- 리스트의 사이즈가 클수록 ArrayList가 더 효율적이다.
- ArrayList는 바로 인덱스에 접근이 가능해 조회가 얼마 안걸리지만 LinkedList는 전부다 순회해야 되서 조회가 오래걸린다.
- ArrayList는 값 추가하거나 빼는게 비효율적인 반면, LinkedList는 값 추가나 빼는게 효율적이다.

```java
Q1. Queue와 Deque 는 무엇인가?
```
