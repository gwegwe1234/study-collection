<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>알고리즘 기초 2 | 끄적끄적 블로그</title>
    <meta name="description" content="개발 관련 블로그">
    <link rel="icon" href="/study-collection/favicon.ico">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:100,300,400,500,700,900|Material+Icons">
    
    <link rel="preload" href="/study-collection/assets/css/0.styles.48760978.css" as="style"><link rel="preload" href="/study-collection/assets/js/app.c7fb18fa.js" as="script"><link rel="preload" href="/study-collection/assets/js/2.18a9e645.js" as="script"><link rel="preload" href="/study-collection/assets/js/39.87019e17.js" as="script"><link rel="prefetch" href="/study-collection/assets/js/10.03d91ed6.js"><link rel="prefetch" href="/study-collection/assets/js/100.ac706883.js"><link rel="prefetch" href="/study-collection/assets/js/101.eac295c6.js"><link rel="prefetch" href="/study-collection/assets/js/102.c3b1d8a0.js"><link rel="prefetch" href="/study-collection/assets/js/103.e45a5323.js"><link rel="prefetch" href="/study-collection/assets/js/104.03b7f2d0.js"><link rel="prefetch" href="/study-collection/assets/js/105.784c063c.js"><link rel="prefetch" href="/study-collection/assets/js/106.3f1e6381.js"><link rel="prefetch" href="/study-collection/assets/js/107.6f3fc730.js"><link rel="prefetch" href="/study-collection/assets/js/108.e9641cd8.js"><link rel="prefetch" href="/study-collection/assets/js/109.55768d54.js"><link rel="prefetch" href="/study-collection/assets/js/11.9a603a29.js"><link rel="prefetch" href="/study-collection/assets/js/110.1d8ab2cd.js"><link rel="prefetch" href="/study-collection/assets/js/111.4732d92c.js"><link rel="prefetch" href="/study-collection/assets/js/112.1c872eaa.js"><link rel="prefetch" href="/study-collection/assets/js/113.d1c2a3e8.js"><link rel="prefetch" href="/study-collection/assets/js/114.4aa47c57.js"><link rel="prefetch" href="/study-collection/assets/js/115.0afa8870.js"><link rel="prefetch" href="/study-collection/assets/js/116.762d6a28.js"><link rel="prefetch" href="/study-collection/assets/js/117.96b44ae8.js"><link rel="prefetch" href="/study-collection/assets/js/118.e4fe548e.js"><link rel="prefetch" href="/study-collection/assets/js/119.b250e002.js"><link rel="prefetch" href="/study-collection/assets/js/12.bec3c98e.js"><link rel="prefetch" href="/study-collection/assets/js/120.1f078326.js"><link rel="prefetch" href="/study-collection/assets/js/121.ce34d936.js"><link rel="prefetch" href="/study-collection/assets/js/122.ede1c91c.js"><link rel="prefetch" href="/study-collection/assets/js/123.d91b5614.js"><link rel="prefetch" href="/study-collection/assets/js/124.b588430e.js"><link rel="prefetch" href="/study-collection/assets/js/125.9089f42d.js"><link rel="prefetch" href="/study-collection/assets/js/126.86a61aa8.js"><link rel="prefetch" href="/study-collection/assets/js/127.33327e49.js"><link rel="prefetch" href="/study-collection/assets/js/128.1631983f.js"><link rel="prefetch" href="/study-collection/assets/js/129.64e5daa5.js"><link rel="prefetch" href="/study-collection/assets/js/13.f4337a3e.js"><link rel="prefetch" href="/study-collection/assets/js/130.9958c764.js"><link rel="prefetch" href="/study-collection/assets/js/131.bafae02f.js"><link rel="prefetch" href="/study-collection/assets/js/132.0dc21ec5.js"><link rel="prefetch" href="/study-collection/assets/js/133.6e2c2c97.js"><link rel="prefetch" href="/study-collection/assets/js/134.bddf1d67.js"><link rel="prefetch" href="/study-collection/assets/js/135.4d85e916.js"><link rel="prefetch" href="/study-collection/assets/js/136.a8ff5326.js"><link rel="prefetch" href="/study-collection/assets/js/137.87771618.js"><link rel="prefetch" href="/study-collection/assets/js/138.ec28462c.js"><link rel="prefetch" href="/study-collection/assets/js/139.e70cd6d1.js"><link rel="prefetch" href="/study-collection/assets/js/14.1a9fbec8.js"><link rel="prefetch" href="/study-collection/assets/js/140.b12925b3.js"><link rel="prefetch" href="/study-collection/assets/js/141.b95481b0.js"><link rel="prefetch" href="/study-collection/assets/js/142.cd2bc017.js"><link rel="prefetch" href="/study-collection/assets/js/15.3f58f488.js"><link rel="prefetch" href="/study-collection/assets/js/16.b2e4b903.js"><link rel="prefetch" href="/study-collection/assets/js/17.65ff2550.js"><link rel="prefetch" href="/study-collection/assets/js/18.4eb50441.js"><link rel="prefetch" href="/study-collection/assets/js/19.64cf9a94.js"><link rel="prefetch" href="/study-collection/assets/js/20.75374a89.js"><link rel="prefetch" href="/study-collection/assets/js/21.53384a3f.js"><link rel="prefetch" href="/study-collection/assets/js/22.031e6229.js"><link rel="prefetch" href="/study-collection/assets/js/23.a3b93bc1.js"><link rel="prefetch" href="/study-collection/assets/js/24.a6c35a88.js"><link rel="prefetch" href="/study-collection/assets/js/25.4ee97473.js"><link rel="prefetch" href="/study-collection/assets/js/26.56d83b66.js"><link rel="prefetch" href="/study-collection/assets/js/27.3ada9c97.js"><link rel="prefetch" href="/study-collection/assets/js/28.82600803.js"><link rel="prefetch" href="/study-collection/assets/js/29.fdadfdfc.js"><link rel="prefetch" href="/study-collection/assets/js/3.719f0592.js"><link rel="prefetch" href="/study-collection/assets/js/30.048c41a2.js"><link rel="prefetch" href="/study-collection/assets/js/31.9b1e0f12.js"><link rel="prefetch" href="/study-collection/assets/js/32.7cf86af5.js"><link rel="prefetch" href="/study-collection/assets/js/33.29344ca8.js"><link rel="prefetch" href="/study-collection/assets/js/34.2e4f52ac.js"><link rel="prefetch" href="/study-collection/assets/js/35.1be0c961.js"><link rel="prefetch" href="/study-collection/assets/js/36.2be530f4.js"><link rel="prefetch" href="/study-collection/assets/js/37.399c0047.js"><link rel="prefetch" href="/study-collection/assets/js/38.8ec46e2f.js"><link rel="prefetch" href="/study-collection/assets/js/4.7c252ab2.js"><link rel="prefetch" href="/study-collection/assets/js/40.72574a8b.js"><link rel="prefetch" href="/study-collection/assets/js/41.871de7dc.js"><link rel="prefetch" href="/study-collection/assets/js/42.5b2244ed.js"><link rel="prefetch" href="/study-collection/assets/js/43.36b52034.js"><link rel="prefetch" href="/study-collection/assets/js/44.fe6a194e.js"><link rel="prefetch" href="/study-collection/assets/js/45.561379bc.js"><link rel="prefetch" href="/study-collection/assets/js/46.6517eba3.js"><link rel="prefetch" href="/study-collection/assets/js/47.b111bc9c.js"><link rel="prefetch" href="/study-collection/assets/js/48.e4165ea9.js"><link rel="prefetch" href="/study-collection/assets/js/49.7a2bd521.js"><link rel="prefetch" href="/study-collection/assets/js/5.617e4672.js"><link rel="prefetch" href="/study-collection/assets/js/50.2be0d2b0.js"><link rel="prefetch" href="/study-collection/assets/js/51.cb2d656c.js"><link rel="prefetch" href="/study-collection/assets/js/52.a90951b1.js"><link rel="prefetch" href="/study-collection/assets/js/53.f4ba21cd.js"><link rel="prefetch" href="/study-collection/assets/js/54.529fa29e.js"><link rel="prefetch" href="/study-collection/assets/js/55.5b2d0568.js"><link rel="prefetch" href="/study-collection/assets/js/56.6acea188.js"><link rel="prefetch" href="/study-collection/assets/js/57.f4758280.js"><link rel="prefetch" href="/study-collection/assets/js/58.b0c005dd.js"><link rel="prefetch" href="/study-collection/assets/js/59.2cca7190.js"><link rel="prefetch" href="/study-collection/assets/js/6.4b1e4938.js"><link rel="prefetch" href="/study-collection/assets/js/60.fbcb6720.js"><link rel="prefetch" href="/study-collection/assets/js/61.1693620f.js"><link rel="prefetch" href="/study-collection/assets/js/62.1f63297e.js"><link rel="prefetch" href="/study-collection/assets/js/63.0c488b28.js"><link rel="prefetch" href="/study-collection/assets/js/64.669fa756.js"><link rel="prefetch" href="/study-collection/assets/js/65.8eac0d66.js"><link rel="prefetch" href="/study-collection/assets/js/66.2bb523fc.js"><link rel="prefetch" href="/study-collection/assets/js/67.bfad7e5d.js"><link rel="prefetch" href="/study-collection/assets/js/68.e50c1a4b.js"><link rel="prefetch" href="/study-collection/assets/js/69.65348d1f.js"><link rel="prefetch" href="/study-collection/assets/js/7.544890a9.js"><link rel="prefetch" href="/study-collection/assets/js/70.c98321e0.js"><link rel="prefetch" href="/study-collection/assets/js/71.67d47856.js"><link rel="prefetch" href="/study-collection/assets/js/72.38d33cc7.js"><link rel="prefetch" href="/study-collection/assets/js/73.d4312358.js"><link rel="prefetch" href="/study-collection/assets/js/74.861a2aef.js"><link rel="prefetch" href="/study-collection/assets/js/75.ef4675b6.js"><link rel="prefetch" href="/study-collection/assets/js/76.51097766.js"><link rel="prefetch" href="/study-collection/assets/js/77.08e3cb15.js"><link rel="prefetch" href="/study-collection/assets/js/78.9436b3a1.js"><link rel="prefetch" href="/study-collection/assets/js/79.12dc11a6.js"><link rel="prefetch" href="/study-collection/assets/js/8.f8d51fcd.js"><link rel="prefetch" href="/study-collection/assets/js/80.c839a571.js"><link rel="prefetch" href="/study-collection/assets/js/81.4e362e51.js"><link rel="prefetch" href="/study-collection/assets/js/82.03cc2df8.js"><link rel="prefetch" href="/study-collection/assets/js/83.aa787442.js"><link rel="prefetch" href="/study-collection/assets/js/84.cf1f1808.js"><link rel="prefetch" href="/study-collection/assets/js/85.7f3e4c6d.js"><link rel="prefetch" href="/study-collection/assets/js/86.11814a92.js"><link rel="prefetch" href="/study-collection/assets/js/87.b6e70d94.js"><link rel="prefetch" href="/study-collection/assets/js/88.4806a78a.js"><link rel="prefetch" href="/study-collection/assets/js/89.cf4f9e3a.js"><link rel="prefetch" href="/study-collection/assets/js/9.6151c5b7.js"><link rel="prefetch" href="/study-collection/assets/js/90.0b121eb1.js"><link rel="prefetch" href="/study-collection/assets/js/91.2cebed9b.js"><link rel="prefetch" href="/study-collection/assets/js/92.135d5309.js"><link rel="prefetch" href="/study-collection/assets/js/93.d591bb67.js"><link rel="prefetch" href="/study-collection/assets/js/94.f0d01d66.js"><link rel="prefetch" href="/study-collection/assets/js/95.dc1f0292.js"><link rel="prefetch" href="/study-collection/assets/js/96.36f02f43.js"><link rel="prefetch" href="/study-collection/assets/js/97.ed4fbae0.js"><link rel="prefetch" href="/study-collection/assets/js/98.f5ae47c5.js"><link rel="prefetch" href="/study-collection/assets/js/99.1d358d8a.js">
    <link rel="stylesheet" href="/study-collection/assets/css/0.styles.48760978.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/study-collection/" class="home-link router-link-active"><!----> <span class="site-name">끄적끄적 블로그</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/study-collection/guide.html" class="nav-link">Guide</a></div><div class="nav-item"><a href="https://github.com/gwegwe1234/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/study-collection/guide.html" class="nav-link">Guide</a></div><div class="nav-item"><a href="https://github.com/gwegwe1234/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/study-collection/guide.html" class="sidebar-link">Intro</a></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Book summary</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>Tech</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading"><span>Programming</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading"><span>Cloud</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading"><span>Computer Science</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading"><span>Devops(?)</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading open"><span>Algorithm</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/study-collection/algorithm/basic1.html" class="sidebar-link">CodePlus 알고리즘 기초 1</a></li><li><a href="/study-collection/algorithm/basic2.html" class="active sidebar-link">CodePlus 알고리즘 기초 2</a></li></ul></section></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="알고리즘-기초-2"><a href="#알고리즘-기초-2" class="header-anchor">#</a> 알고리즘 기초 2</h1> <p></p><div class="table-of-contents"><ul><li><a href="#브루트-포스">브루트 포스</a><ul><li><a href="#브루트-포스">브루트 포스</a></li><li><a href="#경우의-수">경우의 수</a></li><li><a href="#일곱-난쟁이">일곱 난쟁이</a></li><li><a href="#사탕-게임">사탕 게임</a></li><li><a href="#날짜-계산">날짜 계산</a></li><li><a href="#리모컨">리모컨</a></li><li><a href="#테트로미노">테트로미노</a></li></ul></li><li><a href="#건너-뛰며-해보기">건너 뛰며 해보기</a><ul><li><a href="#카잉-달력">카잉 달력</a></li><li><a href="#수-이어-쓰기-1">수 이어 쓰기 1</a></li><li><a href="#_1-2-3-더하기">1,2,3 더하기</a></li></ul></li><li><a href="#n과-m">N과 M</a><ul><li><a href="#n과-m-1">N과 M(1)</a></li><li><a href="#n과-m-2">N과 M(2)</a></li><li><a href="#n과-m-3">N과 M(3)</a></li><li><a href="#n과-m-4">N과 M(4)</a></li></ul></li><li><a href="#순열">순열</a><ul><li><a href="#순열">순열</a></li><li><a href="#다음-순열">다음 순열</a></li><li><a href="#이전-순열">이전 순열</a></li><li><a href="#모든-순열">모든 순열</a></li><li><a href="#차이를-최대로">차이를 최대로</a></li><li><a href="#외판원-순회-2">외판원 순회 2</a></li><li><a href="#로또">로또</a></li></ul></li><li><a href="#재귀">재귀</a><ul><li><a href="#_1-2-3-더하기">1,2,3 더하기</a></li><li><a href="#암호-만들기">암호 만들기</a></li><li><a href="#퇴사">퇴사</a></li><li><a href="#백트랙킹">백트랙킹</a></li><li><a href="#스타트와-링크">스타트와 링크</a></li></ul></li><li><a href="#비트마스크">비트마스크</a></li><li><a href="#그래프">그래프</a><ul><li><a href="#dfs와-bfs까지">DFS와 BFS까지</a></li><li><a href="#단순-경로와-단순-사이클">단순 경로와 단순 사이클</a></li><li><a href="#방향-있는-그래프">방향 있는 그래프</a></li><li><a href="#방향-없는-그래프">방향 없는 그래프</a></li><li><a href="#간선-여러개">간선 여러개</a></li><li><a href="#루프">루프</a></li><li><a href="#가중치">가중치</a></li><li><a href="#차수">차수</a></li><li><a href="#그래프의-표현">그래프의 표현</a></li><li><a href="#인접-행렬">인접 행렬</a></li><li><a href="#인접-리스트">인접 리스트</a></li><li><a href="#간선-리스트">간선 리스트</a></li><li><a href="#abcde">ABCDE</a></li><li><a href="#그래프의-탐색">그래프의 탐색</a></li><li><a href="#깊이-우선-탐색">깊이 우선 탐색</a></li><li><a href="#너비-우선-탐색">너비 우선 탐색</a></li><li><a href="#연결-요소">연결 요소</a></li><li><a href="#이분-그래프">이분 그래프</a></li><li><a href="#단지번호붙이기">단지번호붙이기</a></li><li><a href="#섬의-개수">섬의 개수</a></li><li><a href="#미로-탐색">미로 탐색</a></li><li><a href="#twodots">TwoDots</a></li><li><a href="#서울-지하철-2호선">서울 지하철 2호선</a></li><li><a href="#bfs-스페셜-저지">BFS 스페셜 저지</a></li><li><a href="#다리-만들기">다리 만들기</a></li></ul></li><li><a href="#bfs">BFS</a><ul><li><a href="#숨바꼭질">숨바꼭질</a></li><li><a href="#숨바꼭질-4">숨바꼭질 4</a></li><li><a href="#이모티콘">이모티콘</a></li><li><a href="#덱-사용하기">덱 사용하기</a></li><li><a href="#숨바꼭질-3">숨바꼭질 3</a></li></ul></li><li><a href="#트리">트리</a><ul><li><a href="#루트-있는-트리">루트 있는 트리</a></li><li><a href="#이진-트리">이진 트리</a></li><li><a href="#포화-이진-트리">포화 이진 트리</a></li><li><a href="#완전-이진-트리">완전 이진 트리</a></li><li><a href="#트리의-표현">트리의 표현</a></li><li><a href="#트리의-순회">트리의 순회</a></li><li><a href="#트리의-탐색">트리의 탐색</a></li><li><a href="#트리의-부모-찾기">트리의 부모 찾기</a></li><li><a href="#트리의-지름">트리의 지름</a></li></ul></li></ul></div><p></p> <h2 id="브루트-포스"><a href="#브루트-포스" class="header-anchor">#</a> 브루트 포스</h2> <h3 id="브루트-포스-2"><a href="#브루트-포스-2" class="header-anchor">#</a> 브루트 포스</h3> <ul><li>모든 방법을 다 시도해보는 방법</li> <li>전체 경우의 수가 많지 않을 경우에만 쓴다.</li> <li>경우의 수를 다 해보는데 걸리는 시간이 문제의 시간 제한을 넘지 않아야 한다.</li></ul> <div class="language-java extra-class"><pre class="language-java"><code>문제를 풀기위한 단계 

<span class="token number">1.</span> 문제의 가능한 경우의 수를 다 계산해 본다<span class="token punctuation">.</span>
<span class="token number">2.</span> 가능한 모든 방법을 다 만들어 본다<span class="token punctuation">.</span>
<span class="token number">3.</span> 각각의 방법을 이용해 답을 구해본다<span class="token punctuation">.</span>
</code></pre></div><ul><li>시간복잡도 = 방법의 수 X 방법 1개의 시간 복잡도</li></ul> <h3 id="경우의-수"><a href="#경우의-수" class="header-anchor">#</a> 경우의 수</h3> <ul><li>문제의 가능한 경우의 수를 계산해서 다해보는 것</li></ul> <h3 id="일곱-난쟁이"><a href="#일곱-난쟁이" class="header-anchor">#</a> 일곱 난쟁이</h3> <ul><li>아홉 명의 난쟁이 중 일곱명의 난쟁이를 찾는 문제</li> <li>일곱 난쟁이의 키의 합이 100이다.</li> <li>9C2 = 36가지 경우의 수</li> <li><a href="https://github.com/gwegwe1234/AlgorithmStudy/blob/master/CodePlusAlgo/src/basic2/SevenDwarves.java" target="_blank" rel="noopener noreferrer">구현 소스<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul> <h3 id="사탕-게임"><a href="#사탕-게임" class="header-anchor">#</a> 사탕 게임</h3> <ul><li>N*N 개의 칸에 사탕이 들어있다.</li> <li>인접한 곳의 사탕을 옮겨 같은 색의 사탕중 가장 많이 먹을 수 있는 경우의 수</li> <li>오른쪽 / 아래 의 케이스만 따져 브루트포스로 전부다 비교해본다.</li> <li><a href="https://github.com/gwegwe1234/AlgorithmStudy/blob/master/CodePlusAlgo/src/basic2/CandyGame.java" target="_blank" rel="noopener noreferrer">구현 소스<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul> <h3 id="날짜-계산"><a href="#날짜-계산" class="header-anchor">#</a> 날짜 계산</h3> <ul><li>E, S, M 으로 날짜를 센다.</li> <li><a href="https://www.acmicpc.net/problem/1476" target="_blank" rel="noopener noreferrer">링크<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li>경우의 수가 15 x 28 x 19 로 8천개도 안돼서 브루트 포스에 적합하다</li> <li><a href="https://github.com/gwegwe1234/AlgorithmStudy/blob/master/CodePlusAlgo/src/basic2/CalculateCalender.java" target="_blank" rel="noopener noreferrer">구현 소스<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul> <h3 id="리모컨"><a href="#리모컨" class="header-anchor">#</a> 리모컨</h3> <ul><li>TV 채널을 리모컨으로 바꾸는 문제</li> <li>버튼은 0~9 + -</li> <li>일부 숫자버튼이 망가짐</li> <li>현재 채널이 100일 때 N번으로 가는 최소 횟수</li> <li><a href="https://github.com/gwegwe1234/AlgorithmStudy/blob/master/CodePlusAlgo/src/basic2/RemoteControl.java" target="_blank" rel="noopener noreferrer">구현 소스<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul> <h3 id="테트로미노"><a href="#테트로미노" class="header-anchor">#</a> 테트로미노</h3> <ul><li>N x M 의 칸에 숫자가 있고, 테트리스 블럭을 넣었을때 가장 큰 합을 구하는 문제</li> <li>테트리스 블럭 모양으로 나올 수 있는 경우는 총 19가지 (네모, 기역, 일자 등등..)</li> <li>모든 경우의 수는 19 x N x M 이므로, 브루트 포스에 적합하다.</li> <li>모든 케이스를 배열로 나타내서 if문 19개 생성해서 구함</li></ul> <h2 id="건너-뛰며-해보기"><a href="#건너-뛰며-해보기" class="header-anchor">#</a> 건너 뛰며 해보기</h2> <h3 id="카잉-달력"><a href="#카잉-달력" class="header-anchor">#</a> 카잉 달력</h3> <ul><li>M과 N보다 작거나 같은 두 자연수 x,y를 이용해서 년도를 &lt;x:y&gt;로 표현한다</li> <li>첫 번째 해는 &lt;1:1&gt;, 두 번째 해는 &lt;2,2&gt;</li> <li>x &lt; M -&gt; x +1, 아니면 x = 1</li> <li>y &lt; N -&gt; y +1, 아니면 y = 1</li> <li>총 갯수가 16억개라 건너뛰면서 해야한다</li> <li>M 번 건너뛰면서만 체크해주면 된다.</li> <li>나머지 계산이 필요한 문제는 보통 -1을 해서 하는게 편하다 (5면 5로 나눴을 때 나머지가 0이어야 되는데 그냥 5가나오고 이런문제 발생 가능)</li> <li>어려움..</li> <li><a href="https://github.com/gwegwe1234/AlgorithmStudy/blob/master/CodePlusAlgo/src/basic2/CainCalender.java" target="_blank" rel="noopener noreferrer">구현 소스<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul> <h3 id="수-이어-쓰기-1"><a href="#수-이어-쓰기-1" class="header-anchor">#</a> 수 이어 쓰기 1</h3> <ul><li>1부터 N까지 수를 이어서 쓰면 새로운 하나의 수를 얻게 된다. (1 &lt;= N &lt;= 100,000,000)</li> <li>12345678910111213...</li> <li>새로운 수는 몇자리일까?</li> <li><a href="https://github.com/gwegwe1234/AlgorithmStudy/blob/master/CodePlusAlgo/src/basic2/NumberMarathonWriting.java" target="_blank" rel="noopener noreferrer">구현 소스<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul> <h3 id="_1-2-3-더하기"><a href="#_1-2-3-더하기" class="header-anchor">#</a> 1,2,3 더하기</h3> <ul><li>N중 포문</li> <li>이걸 써야되나..??</li> <li>10중 포문인데.. 재귀함수로 풀라그런다.</li></ul> <h2 id="n과-m"><a href="#n과-m" class="header-anchor">#</a> N과 M</h2> <ul><li>재귀</li> <li>순열</li> <li>비트마스크</li> <li>좀 더 자세하게 공부할 필요가 있어보인다.</li> <li>헷갈림 ㅠ.ㅠ 알고리즘 어려워..</li></ul> <h3 id="n과-m-1"><a href="#n과-m-1" class="header-anchor">#</a> N과 M(1)</h3> <ul><li>1부터 N까지 자연수 중에서 중복없이 M개를 고른 수열을 모두 구하는 문제</li> <li>N = 5, M = 3 (1,2,3)(1,2,4)(1,2,5)(1,3,2)....</li> <li>1 &lt;= M &lt;= N &lt;= 8</li> <li>_ _ _ 세 칸에 들어 갈 수 있는 경우의 수를 찾는다</li> <li><a href="https://github.com/gwegwe1234/AlgorithmStudy/blob/master/CodePlusAlgo/src/basic2/NAndM.java" target="_blank" rel="noopener noreferrer">구현 소스<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul> <h3 id="n과-m-2"><a href="#n과-m-2" class="header-anchor">#</a> N과 M(2)</h3> <ul><li>오름차순 추가</li> <li>재귀 조건에 초기값을 넣어주고, 새로 호출할 때 +1을 해준다</li></ul> <h3 id="n과-m-3"><a href="#n과-m-3" class="header-anchor">#</a> N과 M(3)</h3> <ul><li>중복 가능</li> <li>N과 M (1) 에서 중복만 삭제</li></ul> <h3 id="n과-m-4"><a href="#n과-m-4" class="header-anchor">#</a> N과 M(4)</h3> <ul><li>중복 가능, 비 내림차순</li></ul> <h2 id="순열"><a href="#순열" class="header-anchor">#</a> 순열</h2> <ul><li>브루트 포스인데 순서가 중요한 경우</li></ul> <h3 id="순열-2"><a href="#순열-2" class="header-anchor">#</a> 순열</h3> <ul><li>임의의 수열을 다른 순서로 섞는 연산</li> <li>A = [1,5,6] 인 경우 [1,5,6][1,6,5][5,1,6]...</li> <li>크기가 N인 수열의 서로 다른 순열은 총 N! 개가 있음</li> <li>첫 순열부터 맨 마지막 순열까지 다 구하면된다.</li> <li>다음 순열을 구하는 방법을 구현하면 된다.</li></ul> <h3 id="다음-순열"><a href="#다음-순열" class="header-anchor">#</a> 다음 순열</h3> <ul><li>사전순으로 다음에 오는 순열과 이전에 오는 순열을 찾는 방법</li> <li>자바는 기본구현이 안돼서 구현을 해 줘야 한다.</li> <li>첫 순열은 오름차순, 맨 마지막 순열은 내림차순</li></ul> <div class="language-java extra-class"><pre class="language-java"><code><span class="token number">1.</span> <span class="token class-name">A</span><span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> <span class="token class-name">A</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> 를 만족하는 가장 큰 i를 찾는다
<span class="token number">2.</span> j <span class="token operator">&gt;=</span> i 이면서 <span class="token class-name">A</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&gt;</span> <span class="token class-name">A</span><span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>를 만족하는 가장 큰 j를 찾느다<span class="token punctuation">.</span>
<span class="token number">3.</span> <span class="token class-name">A</span><span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>과 <span class="token class-name">A</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span>를 swap 한다<span class="token punctuation">.</span>
<span class="token number">4.</span> <span class="token class-name">A</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span>부터 순열을 뒤집는다<span class="token punctuation">.</span>
</code></pre></div><ul><li>뒤에서부터 하나씩 비교해가면서 내림차순이 아닌걸 찾는다. 그러면 앞의 것부터 시작한거의 맨 마지막 순열이 된다.</li> <li>예를 들어 7,2,3,6,5,4,1 이 있으면, 뒤에서부터 비교해 보면 7,2,3으로 시작하는 순열의 맨 마지막 순열인 상태이다.</li> <li>그럼 3을 6,5,4,1 에서의 3보다 크면서 위치가 가장 큰 수를 swap (여기선 4)</li> <li>7,2,4,6,5,3,1 상태가 된다.</li> <li>이제 뒤에껄 뒤집는다, 7,2,4,1,3,5,6,</li> <li>바로 7,2,3,6,5,4,1의 다음 순열이 된다.</li> <li>시간 복잡도는 O(N)</li> <li>전체를 찾는 시간복잡도는 N * N!</li> <li><a href="https://github.com/gwegwe1234/AlgorithmStudy/blob/master/CodePlusAlgo/src/basic2/NextPermutation.java" target="_blank" rel="noopener noreferrer">구현 소스<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul> <h3 id="이전-순열"><a href="#이전-순열" class="header-anchor">#</a> 이전 순열</h3> <ul><li>다 똑같은데 부등호만 반대로 해주면 된다.</li> <li>즉 끝에서부터 오름차순을 쭉 찾다가, 오름차순이 끊기는 지점까지 찾고, 오른쪽 부분에서 가장 큰 수와 끊긴 부분을 교환한다</li> <li>이후 뒤에 오름차순 순열을 뒤집어주면 끝</li></ul> <h3 id="모든-순열"><a href="#모든-순열" class="header-anchor">#</a> 모든 순열</h3> <ul><li>do while로 돌리면서, nextPermutation 호출해서 프린트 찍어준다.</li> <li>시작 순열은 전부다 오름차순인 순열</li> <li><a href="https://github.com/gwegwe1234/AlgorithmStudy/blob/master/CodePlusAlgo/src/basic2/EveryPermutation.java" target="_blank" rel="noopener noreferrer">구현 소스<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul> <h3 id="차이를-최대로"><a href="#차이를-최대로" class="header-anchor">#</a> 차이를 최대로</h3> <ul><li>수 N개가 주어졌을 때 (3 &lt;= N &lt;= 8)</li> <li>|A[0] - A[1]| + |A[1] - A[2]| + ... |A[N-2] - A[N-1]|</li> <li>의 최대값 구하기</li> <li>8 보다 작아서 그냥 모든순열 구해서 최댓 값 구하면 된다.</li> <li><a href="https://github.com/gwegwe1234/AlgorithmStudy/blob/master/CodePlusAlgo/src/basic2/BiggestDifferencePermutation.java" target="_blank" rel="noopener noreferrer">구현 소스<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul> <h3 id="외판원-순회-2"><a href="#외판원-순회-2" class="header-anchor">#</a> 외판원 순회 2</h3> <ul><li>1번부터 N번까지 번호가 매겨져 있는 도시가 있다</li> <li>한 도시에서 시작해 N개의 모든 도시를 거쳐 다시 원래 도시로 돌아오려고 한다 (한 번 갔던 도시로는 다시 갈 수 없다)</li> <li>이 때 가장 적은 비용을 구하는 문제</li> <li>W[i][j] = i -&gt; j 비용이 0인 경우는 갈 수 없음</li> <li>N이 매우 커지면 무조건 순열로 푸는건 조심해야 한다.</li> <li>결국 각 도시를 순회하는 방법을 순열로 나타내서, 더하는 부분만 다른 차이를 최대로와 같다</li> <li>여기서 추가로 줄일 수 있는 방법은 1,2,3,4 == 2,3,4,1 == 3,4,1,2 == 4,1,2,3 이다. 즉 시작점을 1로 고정해도 된다.</li></ul> <h3 id="로또"><a href="#로또" class="header-anchor">#</a> 로또</h3> <ul><li>입력으로 주어진 K개의 수 중에서 6개의 수를 고르는 문제</li> <li>고르는 걸 1, 안고르는걸 0</li> <li>0을 k-6개, 1을 6개 넣은 다음 nextPermutation 수행하면 모든 조합을 구할 수 있다.</li></ul> <h2 id="재귀"><a href="#재귀" class="header-anchor">#</a> 재귀</h2> <ul><li>문제를 푸는 순서는 아래와 같다.</li></ul> <div class="language-java extra-class"><pre class="language-java"><code><span class="token number">1.</span> 정답을 찾은 경우
<span class="token number">2.</span> 정답을 못구하는 경우 <span class="token punctuation">(</span>불가능한 경우<span class="token punctuation">)</span>
<span class="token number">3.</span> 다음 경우
</code></pre></div><h3 id="_1-2-3-더하기-2"><a href="#_1-2-3-더하기-2" class="header-anchor">#</a> 1,2,3 더하기</h3> <ul><li>go(count, sum, goal)</li> <li>count -&gt; count + 1</li> <li>sum -&gt; sum + i</li> <li>내부 케이스
<ul><li>안되는 경우 -&gt; sum &gt; goal</li> <li>정답을 찾는 경우  -&gt; sum == goal</li> <li>다음 경우 호출 -&gt; sum(count + 1, sum + i, goal)</li></ul></li> <li>근데 카운트는 만들고나면 필요가없다.. 왜쓴거.. 빼면됨</li></ul> <h3 id="암호-만들기"><a href="#암호-만들기" class="header-anchor">#</a> 암호 만들기</h3> <ul><li>암호는 서로다른 L개의 소문자로 구성, 최소 한개의 모음과 2개의 자음 필요</li> <li>암호의 알파벳은 증가하는 순서</li> <li>암호로 사용할 수 있는 문자의 수는 C가지</li> <li>먼저 정렬을 하고 시작한다.</li> <li>go(n, alpha, password, i)
<ul><li>n : 만들어야 하는 암호의 길이</li> <li>alpha : 사용할 수 있는 알파벳 배열</li> <li>password : 만든 패스워드</li> <li>i : 사용할지 말아야할지 알파벳 인덱스</li></ul></li></ul> <h3 id="퇴사"><a href="#퇴사" class="header-anchor">#</a> 퇴사</h3> <ul><li>N+1일에 퇴사</li> <li>N일까지 최대한 상담을 하는데, 하루에 한번 상담가능</li> <li>i일에 상담하면 T[i]일이 걸리고, P[i]원을 받는다</li></ul> <h3 id="백트랙킹"><a href="#백트랙킹" class="header-anchor">#</a> 백트랙킹</h3> <ul><li>다구하고 필요없는거 빼기</li></ul> <h3 id="스타트와-링크"><a href="#스타트와-링크" class="header-anchor">#</a> 스타트와 링크</h3> <ul><li>두 팀으로 나눠서 차이가 가장 적은거..</li></ul> <h2 id="비트마스크"><a href="#비트마스크" class="header-anchor">#</a> 비트마스크</h2> <ul><li>비트 연산을 통해 부분집합을 표현하는 문제</li> <li>and or not nor 쉬프트 연산</li> <li>쉬프트 연산은 A &lt;&lt; B 면, A x 2의 b승 / A &gt;&gt; B 면, A / 2의 b승</li> <li>비트마스크 : 정수로 집합을 나타낼 수 있다.</li> <li>{1,3,4,5,9} = 570 = 2의1승 + 2의3승 + 2의4승 + 2의5승 + 2의9승</li> <li>정수로 집합을 표현하기 때문에 시간복잡도, 공간복잡도가 아주 작아진다</li> <li>0부터 N-1까지의 정수로 이루어진 집합을 표현</li> <li>위의 집합에서 0이 포함되어 있는지 확인하려면 = 570 &amp; 2의 0승 을 해서 1이 나오는지 확인하면 된다. (비트연산)</li> <li>숫자를 추가해주는건, 특정 위치의 값만 1으로 바꿔주면 된다.</li> <li>즉 1을 추가하려면 570 | 2의1승 을 통해 둘중하나가 0이라도 1로 바뀌도록 연산해주면 된다.</li> <li>제거는 not 연산 후 &amp;를 해준다.</li></ul> <h2 id="그래프"><a href="#그래프" class="header-anchor">#</a> 그래프</h2> <h3 id="dfs와-bfs까지"><a href="#dfs와-bfs까지" class="header-anchor">#</a> DFS와 BFS까지</h3> <ul><li>문제에 나온 상황을 어떻게 그래프로 만들어야 하는지가 중요하다</li> <li>자료구조의 일종</li> <li>정점 (Node, Vertex)</li> <li>간선(Edge): 정점간의 관계를 나타낸다</li> <li>G = (V,E) 라고 표현</li> <li>경로 : 정점 A에서 B로 가는 경로(간선의 연속)</li> <li>사이클 : 정점과 도착점이 같은 그래프</li> <li>문제를 그래프로 모델링 해서 푼다.</li></ul> <h3 id="단순-경로와-단순-사이클"><a href="#단순-경로와-단순-사이클" class="header-anchor">#</a> 단순 경로와 단순 사이클</h3> <ul><li>경로/사이클에서 같은 정점을 두 번 이상 방문하지 않는 경로와 사이클</li> <li>특별한 말이 없으면 일반적으로 단순 경로와 단순 사이클이라고 본다</li></ul> <h3 id="방향-있는-그래프"><a href="#방향-있는-그래프" class="header-anchor">#</a> 방향 있는 그래프</h3> <ul><li>정점간에 방향이 있는 간선이 있을 수 있다.</li></ul> <h3 id="방향-없는-그래프"><a href="#방향-없는-그래프" class="header-anchor">#</a> 방향 없는 그래프</h3> <ul><li>정점간에 방향이 없어, 왔다갔다 가능</li> <li>양방향 그래프라고도 한다</li> <li>보통 문제를 풀때 방향 없는 그래프는 방향 있는 그래프로 바꾼다.</li> <li>ex. A-C = A-&gt;C / C-&gt;A</li></ul> <h3 id="간선-여러개"><a href="#간선-여러개" class="header-anchor">#</a> 간선 여러개</h3> <ul><li>두 정점 사이에 간선이 여러 개 일 수 있다.</li></ul> <h3 id="루프"><a href="#루프" class="header-anchor">#</a> 루프</h3> <ul><li>간산의 양 끝점이 같은 경우</li> <li>A-&gt;A</li> <li>이론적인거고 문제로 풀경운 거의없다</li></ul> <h3 id="가중치"><a href="#가중치" class="header-anchor">#</a> 가중치</h3> <ul><li>간선에 가중치가 있는 경우</li> <li>A에서 B로 이동하는 거리, 이동하는데 필요한 시간, 이동하는데 필요한 비용 등등..</li></ul> <h3 id="차수"><a href="#차수" class="header-anchor">#</a> 차수</h3> <ul><li>정점과 연결되어 있는 간선의 개수</li> <li>방향 그래프에는 indegree와 outdegree로 나눠서 차수를 계산한다</li></ul> <h3 id="그래프의-표현"><a href="#그래프의-표현" class="header-anchor">#</a> 그래프의 표현</h3> <ul><li>정점이 6개, 간선이 8개</li> <li>방향이 없는 그래프이다</li> <li>정점 : {1,2,3,4,5,6}</li> <li>간선 : {(1,2), (1,5), (2,5), (2,3), (3,4), (2,4), (4,5), (4,6)}</li></ul> <p><img src="/study-collection/assets/img/codeplus2-1.0ab595c5.png" alt="alt"></p> <ul><li>그래프 저장 방법</li></ul> <div class="language-java extra-class"><pre class="language-java"><code><span class="token number">1.</span> 인접 행렬
<span class="token number">2.</span> 인접 리스트
</code></pre></div><h3 id="인접-행렬"><a href="#인접-행렬" class="header-anchor">#</a> 인접 행렬</h3> <ul><li>정점의 개수를 V라고 했을 때,</li> <li>V X V 크기의 이차원 배열을 이용한다.</li> <li>A[i][j] = 1 (i -&gt; j 간선이 있을때), 0 (없을 때) / 가중치가 있으면 가중치 값을 넣어준다</li> <li>공간 복잡도 : O(V제곱)</li></ul> <h3 id="인접-리스트"><a href="#인접-리스트" class="header-anchor">#</a> 인접 리스트</h3> <ul><li>A[i] = i 와 연결된 정점을 리스트로 포함하고 있음</li> <li>A[1] = 2,5...</li> <li>가중치가 있으면 A[1] = (2,2) (2,5) 이렇게 준다.</li> <li>링크드리스트 같은 동적으로 길이 변경할 수 있는 배열을 사옹해야 한다.</li> <li>공간 복잡도 : O(E) == 간선의 갯수</li> <li>인접 리스트가 공간,시간복잡도면에서 인접행렬보다 더 좋다.</li> <li>결국 거의 모든 케이스는 인접리스트만 사용한다</li></ul> <h3 id="간선-리스트"><a href="#간선-리스트" class="header-anchor">#</a> 간선 리스트</h3> <ul><li>배열을 이용해서 구현한다.</li> <li>간선을 모두 저장하고 있다.</li> <li>1차원 배열에 싹다 저장하는거</li></ul> <h3 id="abcde"><a href="#abcde" class="header-anchor">#</a> ABCDE</h3> <ul><li>총 N명의 친구 관계가 주어졌을때</li> <li>다음과 같은 친구 관계가 존재하는지 구하는 문제</li> <li>A는 B와 친구다.</li> <li>B와 C와 친구다</li> <li>C D 친구</li> <li>D E 친구</li> <li><a href="https://github.com/gwegwe1234/AlgorithmStudy/blob/master/CodePlusAlgo/src/basic2/NextPermutation.java" target="_blank" rel="noopener noreferrer">구현 소스<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul> <h3 id="그래프의-탐색"><a href="#그래프의-탐색" class="header-anchor">#</a> 그래프의 탐색</h3> <ul><li>목적 : 임의의 정점에서 시작해서 연결되어 있는 모든 정점을 한번씩 방문하는 것</li> <li>DFS / BFS 둘 다 위의 목적을 이루기 위한 알고리즘 방식</li> <li>DFS : 깊이 우선 탐색 -&gt; 한명이 왔다갔다 하는방법 (Stack)</li> <li>BFS : 너비 우선 탐색 -&gt; 사람이 복제되면서 하는 방법 (Queue)</li></ul> <h3 id="깊이-우선-탐색"><a href="#깊이-우선-탐색" class="header-anchor">#</a> 깊이 우선 탐색</h3> <ul><li>스택을 이용해서 갈 수 있는 만큼 최대한 많이 가고</li> <li>갈 수 없으면 이전 정점으로 돌아간다</li> <li>check 배열을 만든다.</li> <li>특정 정점을 방문하면, check[i] 에 1을 추가한다.</li> <li>방문한곳을 스택에 넣어준다</li> <li>그러다 갈 수 없는곳에 도착하면 스택에서 마지막에 넣은거 뺀다</li> <li>다 가게되면 스택에서 쫘라락 다 빠질텐데, 스택이 비면 모든 정점을 방문했다고 볼 수 있다</li> <li><a href="https://codeplusattachment.s3.ap-northeast-1.amazonaws.com/5eef326b6e3cfe22851b09a3842e19d23eb35387/600%20-%20%E1%84%80%E1%85%B3%E1%84%85%E1%85%A2%E1%84%91%E1%85%B3%201.pdf?AWSAccessKeyId=AKIAIZC5BNYL4YLIYQPA&amp;Expires=1607423179&amp;Signature=8x%2FUx3vGf0ezMtuudvqaEf%2FtQXA%3D" target="_blank" rel="noopener noreferrer">그림참조<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li>재귀를 통해 구현이 가능하다</li></ul> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">// 인접 행렬을 이용한 구현</span>
<span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    check<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> check<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token boolean">false</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">dfs</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><ul><li>시간 복잡도는 O(V의 제곱)</li></ul> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">// 인접 리스트를 이용한 구현</span>
<span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    check<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> a<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 인접 리스트에 실제 값을 땡겨와서 check함수로 체크한다</span>
        <span class="token keyword">int</span> y <span class="token operator">=</span> a<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>check<span class="token punctuation">[</span>y<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token boolean">false</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">dfs</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><ul><li>시간 복잡도는 O(V+E)</li></ul> <h3 id="너비-우선-탐색"><a href="#너비-우선-탐색" class="header-anchor">#</a> 너비 우선 탐색</h3> <ul><li>큐를 이용해서 지금위치에서 갈 수 있는 것을 모두 큐에 넣는 방식</li> <li>큐에 넣었을 때 방문했다고 체크해야 한다</li> <li><a href="https://codeplusattachment.s3.ap-northeast-1.amazonaws.com/5eef326b6e3cfe22851b09a3842e19d23eb35387/600%20-%20%E1%84%80%E1%85%B3%E1%84%85%E1%85%A2%E1%84%91%E1%85%B3%201.pdf?AWSAccessKeyId=AKIAIZC5BNYL4YLIYQPA&amp;Expires=1607423179&amp;Signature=8x%2FUx3vGf0ezMtuudvqaEf%2FtQXA%3D" target="_blank" rel="noopener noreferrer">그림참조<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">// 인접행렬</span>
<span class="token class-name">Queue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token keyword">int</span><span class="token punctuation">&gt;</span></span> q<span class="token punctuation">;</span>
check<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>q<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> x <span class="token operator">=</span> q<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    q<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> check<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token boolean">false</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 큐에 넣을 때 방문했다고 체크해준다</span>
            check<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
            q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">// 인접 리스트</span>
<span class="token class-name">Queue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token keyword">int</span><span class="token punctuation">&gt;</span></span> q<span class="token punctuation">;</span>
check<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>q<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> x <span class="token operator">=</span> q<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    q<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> a<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> y <span class="token operator">=</span> a<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>check<span class="token punctuation">[</span>y<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token boolean">false</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 큐에 넣을 때 방문했다고 체크해준다</span>
            check<span class="token punctuation">[</span>y<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
            q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="연결-요소"><a href="#연결-요소" class="header-anchor">#</a> 연결 요소</h3> <ul><li>아래 그림과 같이 나누어져 있지 않은 경우가 있을 수 있음</li> <li>이렇게 나누어진 각각의 그래프를 연결 요소라고 한다.</li> <li>연결 요소에 속한 모든 정점을 연결하는 경로가 있어야 한다.</li> <li>또 따른 연결 요소에 속한 정ㅈ머과 연결하는 경로가 있으면 안된다.</li> <li>아래는 2개의 연결요소로 되어 있다.</li> <li>연결요소를 구하는 것은 DFS나 BFS를 사용하면 된다.</li> <li><a href="https://github.com/gwegwe1234/AlgorithmStudy/blob/master/CodePlusAlgo/src/basic2/FindYungyulYoso.java" target="_blank" rel="noopener noreferrer">구현 소스<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul> <p><img src="/study-collection/assets/img/codeplus2-2.8f63909b.png" alt="alt"></p> <h3 id="이분-그래프"><a href="#이분-그래프" class="header-anchor">#</a> 이분 그래프</h3> <ul><li>그래프를 아래와 같이 A와 B로 나눌 수 있으면 이분 그래프</li> <li>A에 포함되어 있는 정점끼리 연결된 간선이 없음</li> <li>B에 포함되어 있는 정점끼리 연결된 간선이 없음</li> <li>모든 간선의 한 끝 점은 A에, 다른 끝 점은 B에</li></ul> <p><img src="/study-collection/assets/img/codeplus2-3.326bcff8.png" alt="alt"></p> <h3 id="단지번호붙이기"><a href="#단지번호붙이기" class="header-anchor">#</a> 단지번호붙이기</h3> <ul><li>정사각형 모양의 지도가 있다</li> <li>0은 집이 없는곳, 1은 집이 있는곳</li> <li>지도를 가지고 연결된 집의 모임인 단지를 정의하고, 단지에 번호를 붙인다.</li> <li>연결 : 좌우 아래위로 집이 있는 경우</li></ul> <h3 id="섬의-개수"><a href="#섬의-개수" class="header-anchor">#</a> 섬의 개수</h3> <h3 id="미로-탐색"><a href="#미로-탐색" class="header-anchor">#</a> 미로 탐색</h3> <ul><li>(1,1)에서 (N,M)으로 가는 가장 빠른 길을 구하는 문제</li> <li>DFS로는 못품</li> <li>BFS 탐색 사용</li> <li>BFS는 단계별로 진행돼서 구할 수 있음</li> <li><a href="https://github.com/gwegwe1234/AlgorithmStudy/blob/master/CodePlusAlgo/src/basic2/FindBestWayOfMaze.java" target="_blank" rel="noopener noreferrer">구현 소스<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul> <h3 id="twodots"><a href="#twodots" class="header-anchor">#</a> TwoDots</h3> <ul><li><a href="https://github.com/gwegwe1234/AlgorithmStudy/blob/master/CodePlusAlgo/src/basic2/TwoDots.java" target="_blank" rel="noopener noreferrer">구현 소스<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul> <h3 id="서울-지하철-2호선"><a href="#서울-지하철-2호선" class="header-anchor">#</a> 서울 지하철 2호선</h3> <h3 id="bfs-스페셜-저지"><a href="#bfs-스페셜-저지" class="header-anchor">#</a> BFS 스페셜 저지</h3> <ul><li>입력으로 주어진 정보가 BFS 탐색을 진행하면서 올바른 결과인지 살펴본다</li></ul> <h3 id="다리-만들기"><a href="#다리-만들기" class="header-anchor">#</a> 다리 만들기</h3> <ul><li>단지 붙이기 + 토마토</li></ul> <h2 id="bfs"><a href="#bfs" class="header-anchor">#</a> BFS</h2> <ul><li>BFS는 모든 가중치가 1일 때 최단 거리를 구하는 알고리즘</li> <li>문제 조건
<ul><li>최소비용 문제이어야 한다</li> <li>간선의 가중치가 1이어야 한다</li> <li>정점과 간선의 개수가 적어야 한다</li></ul></li></ul> <h3 id="숨바꼭질"><a href="#숨바꼭질" class="header-anchor">#</a> 숨바꼭질</h3> <ul><li>수빈이의 위치 : N</li> <li>동생의 위치 : K</li> <li>동생을 찾는 가장 빠른 시간을 구하는 문제</li> <li>수빈이가 할 수 있는 행동 (위치 : X)
<ul><li>걷기 X+1, X-1로 이동(1초)</li> <li>순간이동 : 2 * X로 이동 (1초)</li></ul></li> <li>이 문제에서 정점 : 위치</li> <li>이 문제에서 간선 : 위치 - 위치 (걷기 또는 순간이동)</li> <li>check[i] = i를 방문했는지 여부</li> <li>dist[i] = i를 몇 번만에 방문했는지 기록</li></ul> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">if</span><span class="token punctuation">(</span>check<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span><span class="token boolean">false</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
    check<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span> 
    q<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span> 
    dist<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">=</span> dist<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><ul><li><a href="https://github.com/gwegwe1234/AlgorithmStudy/blob/master/CodePlusAlgo/src/basic2/HideAndSeek.java" target="_blank" rel="noopener noreferrer">구현 소스<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul> <h3 id="숨바꼭질-4"><a href="#숨바꼭질-4" class="header-anchor">#</a> 숨바꼭질 4</h3> <ul><li>숨바꼭질 1 에 이동하는 방법도 추가해서 구하는 문제</li> <li>역추적이 필요하다</li> <li>from[i] = 어디에서 왔는지</li> <li>from[i] -&gt; i</li> <li>N에서 K를 가는 문제 이기 때문에</li> <li>K부터 from을 통해서 N까지 가야한다.</li> <li>즉 역순으로 저장되기 때문에 역순으로 구하는 것이 필요</li> <li>Stack or 재귀로 구해준다.</li> <li><a href="https://github.com/gwegwe1234/AlgorithmStudy/blob/master/CodePlusAlgo/src/basic2/HideAndSeek4.java" target="_blank" rel="noopener noreferrer">구현 소스<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul> <h3 id="이모티콘"><a href="#이모티콘" class="header-anchor">#</a> 이모티콘</h3> <ul><li>화면에 이모티콘은 1개</li> <li>할 수 있는 연산
<ul><li>화면에 있는 이모티콘을 모두 복사해서 클립보드에 저장</li> <li>크립보드에 있는 모든 이모티콘을 화면에 붙여넣기</li> <li>화면에 있는 이모티콘 중 하나를 삭제</li></ul></li> <li>S개의 이모티콘을 만드는데 걸리는 시간의 최소값을 구하는 문제</li></ul> <h3 id="덱-사용하기"><a href="#덱-사용하기" class="header-anchor">#</a> 덱 사용하기</h3> <ul><li>가중치가 0과 1인애들도 구할 수 있다</li></ul> <h3 id="숨바꼭질-3"><a href="#숨바꼭질-3" class="header-anchor">#</a> 숨바꼭질 3</h3> <ul><li>순간이동은 시간이 0초걸린다고 가정</li> <li>덱.. 사용..</li></ul> <h2 id="트리"><a href="#트리" class="header-anchor">#</a> 트리</h2> <ul><li>자료구조의 일종</li> <li>사이클이 없는 연결 그래프</li> <li>정점의 개수 : V</li> <li>간선의 개수 : V-1</li> <li>연결되어 있다</li></ul> <h3 id="루트-있는-트리"><a href="#루트-있는-트리" class="header-anchor">#</a> 루트 있는 트리</h3> <ul><li>루트는 정하기 나름</li> <li>부모관계가 생김</li> <li>parent가 없는 노드는 루트이다</li> <li>자식이 없는 노드는 단말 정점 or Leaf 노드</li> <li>형제도 있음</li> <li>깊이 : 루트에서부터의 거리</li> <li>조상, 자손 : p-&gt;q로 루트를 통과하지 않고 갈 수 있을 때</li></ul> <h3 id="이진-트리"><a href="#이진-트리" class="header-anchor">#</a> 이진 트리</h3> <ul><li>자식을 최대 2개만 가지고 있는 트리</li></ul> <h3 id="포화-이진-트리"><a href="#포화-이진-트리" class="header-anchor">#</a> 포화 이진 트리</h3> <ul><li>리프노드를 제외한 노드의 자식수는 2</li> <li>형제 노드의 수가 일정하게 늘어난다</li></ul> <h3 id="완전-이진-트리"><a href="#완전-이진-트리" class="header-anchor">#</a> 완전 이진 트리</h3> <ul><li>리프노드의 자식 수 : 0</li> <li>포화 이진트리랑은 다르게 높이가 다를 수 있다</li></ul> <h3 id="트리의-표현"><a href="#트리의-표현" class="header-anchor">#</a> 트리의 표현</h3> <ul><li>트리는 그래프이기 때문에, 그래프의 표현과 같은 방식으로 저장할 수 있다.</li> <li>또는</li> <li>트리의 모든 노드는 부모를 하나 또는 0개만 가지기 때문에 부모만 저장하는 방식으로 저장할 수 있다</li> <li>부모가 0개인 경우는 트리의 루트인데, 이 경우 부모를 -1 또는 0으로 처리하는 방식을 사용한다</li> <li><code>완전 이진 트리</code>의 경우에는 배열로 표현할 수 있다.</li> <li>부모의 노드가 x인 경우에 자식의 노드는 2<em>x, 2</em>x+1로 나타내면 된다.</li> <li>그냥 이진트리의 경우에는 클래스나 구조체로 표현 가능</li></ul> <h3 id="트리의-순회"><a href="#트리의-순회" class="header-anchor">#</a> 트리의 순회</h3> <ul><li>트리의 모든 노드를 방문하는 순서이다.</li> <li>그래프의 경우에는 DFS와 BFS가 있다</li> <li>DFS는 아래와 같은 3가지 출력 순서가 있다
<ul><li>프리오더 : 노드방문 - 왼쪽 자식 프리오더 - 오른쪽 자식 프리오더</li> <li>인오더 : 왼쪽 자식 인오더 - 노드방문 - 오른쪽 자식 인오더</li> <li>포스트오더 : 왼쪽자식 포스트오더 - 오른쪽 자식 포스트오더 - 노드방문</li></ul></li> <li>세 방법의 차이는 노드 방문 처리를 언제 할 것인가이다.</li> <li><a href="https://github.com/gwegwe1234/AlgorithmStudy/blob/master/CodePlusAlgo/src/basic2/TreeCircuit.java" target="_blank" rel="noopener noreferrer">구현 소스<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul> <h3 id="트리의-탐색"><a href="#트리의-탐색" class="header-anchor">#</a> 트리의 탐색</h3> <ul><li>트리의 탐색은 DFS/BFS 알고리즘을 이용해서 할 수 있다.</li> <li>트리는 사이클이 없는 그래프이기 때문</li> <li>임의의 두 정점 사이의 경로는 1개이다.</li> <li>따라서, BFS 알고리즘을 이용해서 최단 거리를 구할 수 있다.</li> <li>이유 : 경로가 1개라 찾은 그 경로가 최단 경로</li></ul> <h3 id="트리의-부모-찾기"><a href="#트리의-부모-찾기" class="header-anchor">#</a> 트리의 부모 찾기</h3> <ul><li>트리를 그래프로 입력받고</li> <li>루트를 1이라고 정했을 때</li> <li>각 노드의 부모를 찾는 문제</li> <li>BFS로 해결 가능</li></ul> <h3 id="트리의-지름"><a href="#트리의-지름" class="header-anchor">#</a> 트리의 지름</h3> <ul><li>트리에 존재하는 모든 경로 중에서 가장 긴 것의 길이를 트리의 지름이라고 한다</li> <li>트리의 지름은 탐색 2번으로 구할 수 있다.</li></ul> <div class="language-java extra-class"><pre class="language-java"><code><span class="token number">1.</span> 한 정점 s에서 모든 정점까지의 거리를 구한다<span class="token punctuation">.</span> 이 때 가장 먼 거리인 정점을 u라고 한다
<span class="token number">2.</span> u에서 모든 정점까지의 거리를 구한다<span class="token punctuation">.</span> 이 때 가장 먼 거리인 정점 v를 구한다<span class="token punctuation">.</span>
</code></pre></div><ul><li>d(u,v)를 u와 v사이의 거리라고 했을 때, d(u,v)기 트리의 지름</li></ul></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/study-collection/algorithm/basic1.html" class="prev">CodePlus 알고리즘 기초 1</a></span> <!----></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/study-collection/assets/js/app.c7fb18fa.js" defer></script><script src="/study-collection/assets/js/2.18a9e645.js" defer></script><script src="/study-collection/assets/js/39.87019e17.js" defer></script>
  </body>
</html>
