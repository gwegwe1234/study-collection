# 5강
## 1. 스프링 MVC 시작하기
- 사용자가 웹브라우저에서 작업을 하면, 리퀘스트가 서버로 들어가고, 작업 처리 후 리스폰스를 반환한다.
- 그 작업 처리를 해주는 부분이 스프링 MVC 이다.

![Alt text](../../images/book/mvc1.jpg)

- 1에서 리퀘스트가 들어 올 때, 사용자가 원하는 정보가 포함되어 전달이 된다.
- 리퀘스트의 첫 정거장은 프로트 컨트롤러 역할을 하는 DispatcherServlet이다.
- DispatcherServlet의 임무는 리퀘스트를 스프링 MVC 컨트롤러로 전달하는 일이다.
- 일반적으로 어플리케이션은 여러개의 컨트롤러가 있어서 어떠한 컴포넌트로 찾아갈지 2의 핸들러 매핑에게 도움을 청한다.
- 핸들러 매핑을 통해 컨트롤러가 선택되면, DispatcherServlet은 선택된 컨트롤러 3으로 리퀘스트를 전달한다.
- 컨트롤러에서 요청은 페이로드 (사용자에 의해 입력된 정보) 를 떨군다. 
- 컨트롤러가 내부 로직을 타서 리퀘스트를 잘 처리하면, 브라우저에 표시되기 위한 형태의 정보를 반환하는데, 이것을 보통 모델이라고 한다.
- 이때 컨트롤러는 뷰의 이름도 같이 던지게 되는데, DispatcherServlet은 이걸 받아서 view resolver에서 적절핟 뷰를 매핑해 다시 던져준다.
- 위의 작업이 완료되면, 이제 리스폰스에 해당 정보를 담아 화면단으로 던져준다.

## 2. 스프링 MVC 설정하기
### 2-1. DispatcherServlet 설정하기
- DispatcherServlet을 설정하는 방법은 web.xml 과 java 설정이 있다. web.xml은 버림

```java
public class SpittrWebAppInitializer
        extends AbstractAnnotationConfigDispatcherServletInitializer {
        
        @Override
        protected String[] getServletMappings() {
            //DispatcherServlet을 /에 매핑
            return new String[] {"/"};
        }

        @Override
        protected Class<?>[] getRootConfigClasses() {
            return new Class<?>[] {RootConfig.class};
        }

        @Override
        protected Class<?>[] getServletConfigClasses() {
            // 설정 클래스를 지정해 준다.
            return new Class<?>[] {WebConfig.class};
        }
    }
```
 
- 서블릿 3.0 환경에서 컨테이너는 클래스패스 내의 javax.servlet.ServletContainerInitializer 인터페이스를 구현한 모든 클래스들을 찾아보도록 되어 있다.
- 여기서 발견된 클래스들은 서블릿 컨테이너들을 설정하는데 사용된다.
- 스프링은 SpringServletContainerInitailizer의 구현을 제공하고, 순차적으로 WebApplicationInitializer의 구현 클래스를 찾아 설정을 위임한다.
- 스프링에선 AbstractAnnotationConfigDispatcherServletInitializer라고 하는 미리 구성되어있는 WebApplicationInitializer의 구현체를 만들어 놓았다.
- 위의 코드 설정도, AbstractAnnotationConfigDispatcherServletInitializer를 상속 받아 기초 설정들을 스프링이 찾을 수 있도록 설정을 해 주었음.

### 2-2. 두 애플리케이션 컨텍스트
- DispatcherServlet이 시작되면 스프링 어플리케이션 컨텍스트를 생성하고, WebConfig 에서 설정된 빈을 로딩한다.
- DispatcherServlet은 컨트롤러, 뷰리졸버, 핸들러 매핑과 같은 웹 컴포넌트가 포함된 빈을 로딩한다.
- ContextLoaderListener는 그 외의 다른 빈들을 로딩한다.
- 내부적으로 AbstractAnnotationConfigDispatcherServletInitializer는 DispatcherServlet과 ContextLoaderListenr를 생성한다.
- ContextLoader의 설정은 RootConfig 에 설정되어있고, DispatcherServlet은 WebConfig에 설정 되어 있다.
- 이러한 java클래스를 사용한 DispatcherServlet 설정 방식은 톰캣 7 과 같이 서블릿 3.0 이상을 지원하는 서버에서반 작동을 한다.

### 2-3 스프링 MVC 활성화하기
- 가장 간단하게 MVC 설정 방법은 @EnableWebMvc 어노테이션을 붙여주는거다
```java
@Configuration
@EnableWebMvc
public class WebConfig {
    
}
```
- 위와 같이 설정하면, 기본적인 MVC를 적용한다는 것을 스프링에겐 알려주지만 조금더 디테일한 설정이 필요하다

```java
@Configuration
@EnableWebMvc // Spring MVC 활성화
@ComponentScan("spitter.web") // component scan 활성화
public class WebConfig
public class WebConfig extends WebMvcConfigurerAdapter {
    @Bean
    public ViewResolver viewResolver() {
        // JSP 뷰 리졸버 설정
        InternalResourceViewResolver resolver = new InternalResourceViewResolver();
        resolver.setPrefix("/WEB-INF/views/");
        resolver.setSuffix(".jsp");
        resolver.setExposeContextBeansAsAttributes(true);
        return resolver;
    }

    @Override
    public void configurerDefaultServletHandling(
        DefaultServlethandlerConfigurer configurer) {
        // 정적 콘텐츠 처리 설정
        configurer.enalbe();
    }
}
```

- 이런식으로 추가적인 설정을 통해 필요한 설정들을 해줘야 한다.
- 참고 RootConfig
```java
@Configuration
@ComponentScan(basePackages={"spitter"},
    excludeFilters={
        @Filter(type=FilterType.ANNOTATION, value=EnableWebMvc.class)
    })
public class RootConfig {
    // 자세한건 뒤에서 보도록합시당
}
```

## 3. Spitter 어플리케이션 소개
- Spring + Twitter 란다..
- MVC 에서 컨트롤러는 메소드를 포함하는 단순한 클래스, @RequestMapping이 있다.

```java
@Controller
public class HomeController {

  @RequestMapping(value="/", method=GET)
  public String home() {
    return "home";
  }
}
```

- 위의 컨트롤러에서 리턴을 단순히 스트링 "home"을 해주지만, 이 String은 스프링 MVC에 의해 렌더링할 뷰의 이름으로 해석이 된다.
- DispatcherServlet은 뷰 리졸버에게 이 뷰의 이름으로 실제 뷰를 결정하도록 요청한다.
- 실제로 WebConfig에서 jsp로 설정을 해서 home.jsp로 찾아가게 된다.

